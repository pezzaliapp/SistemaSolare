<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CubeSat Orbit Lab — pezzaliAPP (v4.2)</title>
<style>
:root{--bg:#050a1e;--bg2:#0a1233;--ink:#eaf1ff;--muted:#99add6;--line:#1b2a66;--accent:#8b5cf6;--glow:#2dd4bf}
*{box-sizing:border-box}html,body{height:100%}
body{margin:0;font:15px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--ink);
background:radial-gradient(1200px 600px at 50% -20%,#121b46 15%,transparent 60%),linear-gradient(180deg,var(--bg) 0%,var(--bg2) 100%)}
header{position:sticky;top:0;z-index:10;background:#081133cc;backdrop-filter:blur(8px);border-bottom:1px solid var(--line)}
.header-inner{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;position:relative}
h1{margin:0;font-size:16px;letter-spacing:.3px;white-space:nowrap;background:linear-gradient(90deg,#c9d6ff,#a3eeda,#c9d6ff);
-webkit-background-clip:text;background-clip:text;color:transparent;animation:titleflow 10s linear infinite}
@keyframes titleflow{0%{background-position:0% 50%}100%{background-position:200% 50%}}
.badge{display:inline-block;margin-left:8px;padding:2px 8px;border-radius:999px;background:#14204e;color:#a7b7ef;font:700 11px/1 ui-monospace;box-shadow:0 0 0 1px #24357a inset}
header::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:linear-gradient(90deg,transparent,var(--accent),var(--glow),transparent);
filter:blur(.6px);opacity:.8;animation:flow 6s linear infinite}
@keyframes flow{0%{background-position:-200px 0}100%{background-position:200px 0}}
main{max-width:1200px;margin:0 auto;padding:14px}
.canvas-wrap{position:relative;border:1px solid var(--line);border-radius:18px;overflow:hidden;background:radial-gradient(900px 500px at 50% 10%,#0d1433 10%,#0a0f2a 70%);
box-shadow:0 30px 60px rgba(0,0,0,.35),0 0 0 1px #0c183f inset}
canvas{display:block;width:100%;height:auto;touch-action:none}
.hud{position:absolute;left:10px;top:10px;font:12px/1.25 ui-monospace,Menlo,Consolas,monospace;color:#cfe2ff;text-shadow:0 1px 0 #000;background:#0a0f2acc;
padding:8px 10px;border-radius:10px;border:1px solid #1a2355;box-shadow:0 0 0 1px rgba(45,212,191,.2),0 0 20px rgba(45,212,191,.08)}
.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:14px;margin-top:14px}
.controls .group{background:linear-gradient(180deg,#0f1742,#0a102f);border:1px solid var(--line);border-radius:14px;padding:12px}
.controls label{display:block;font-size:13px;color:var(--muted);margin-bottom:8px}
.controls input[type=range]{width:100%}
.controls .toggles{display:flex;gap:16px;flex-wrap:wrap}
.small{font-size:12px;color:var(--muted)}
footer{padding:18px;text-align:center;color:var(--muted)}
.hidden{display:none}
button.xls{border:1px solid var(--line);background:#0f1837;color:var(--ink);padding:8px 12px;border-radius:12px;cursor:pointer;font-weight:700}
.hud .warn{color:#ffd7a8}
</style>
</head>
<body>
<header>
  <div class="header-inner">
    <h1>CubeSat Orbit Lab — pezzaliAPP <span class="badge">+ Sistema Solare</span></h1>
    <div class="small">CubeSat / 8 Pianeti · ω/M₀ · Drag · Export Excel · Zoom/Drag · Beacon radio</div>
  </div>
</header>

<main>
  <section class="canvas-wrap">
    <canvas id="view" width="1200" height="675" aria-label="Simulazione orbite"></canvas>
    <div class="hud" id="hud">loading…</div>
  </section>

  <section class="controls">
    <div class="group">
      <label>Modalità
        <select id="mode">
          <option value="cubesat" selected>CubeSat (intorno alla Terra)</option>
          <option value="solarsys">Sistema Solare (8 pianeti)</option>
        </select>
      </label>
      <label>Velocità simulazione
        <input id="timescale" type="range" min="0.1" max="300" step="0.1" value="6">
        <span id="timescaleVal">6×</span>
      </label>
      <p class="small">Rotellina = zoom · trascina = ruota camera</p>
    </div>

    <!-- CubeSat -->
    <div class="group cs-only">
      <label>Scenario
        <select id="scenario">
          <option value="leo" selected>LEO Circolare 400 km</option>
          <option value="launch">Lancio → Inserimento</option>
          <option value="ellipse">Ellittica 300 × 800 km</option>
          <option value="gto">GTO semplificata</option>
        </select>
      </label>
    </div>
    <div class="group cs-only">
      <label>Altitudine Perigeo (km)
        <input id="perigee" type="range" min="180" max="2000" step="10" value="400"><span id="perigeeVal">400</span>
      </label>
      <label>Altitudine Apogeo (km)
        <input id="apogee" type="range" min="180" max="36000" step="10" value="400"><span id="apogeeVal">400</span>
      </label>
    </div>
    <div class="group cs-only">
      <label>Inclinazione i (°)
        <input id="incl" type="range" min="0" max="98" step="1" value="51"><span id="inclVal">51</span>
      </label>
      <label>RAAN Ω (°)
        <input id="raan" type="range" min="0" max="360" step="1" value="0"><span id="raanVal">0</span>
      </label>
      <label>Argomento del perigeo ω (°)
        <input id="argp" type="range" min="0" max="360" step="1" value="0"><span id="argpVal">0</span>
      </label>
      <label>Anomalia media M₀ (°)
        <input id="m0" type="range" min="0" max="360" step="1" value="0"><span id="m0Val">0</span>
      </label>
    </div>
    <div class="group cs-only">
      <label>Trail
        <input id="trail" type="range" min="0" max="2000" step="10" value="800"><span id="trailVal">800</span>
      </label>
      <div class="toggles">
        <label><input type="checkbox" id="showAxes" checked> Assi</label>
        <label><input type="checkbox" id="showOrbit" checked> Orbita</label>
        <label><input type="checkbox" id="atmo" checked> Atmosfera</label>
        <label><input type="checkbox" id="shadow" checked> Ombra Terra</label>
      </div>
    </div>
    <div class="group cs-only">
      <label><input type="checkbox" id="drag"> Attiva resistenza atmosferica (LEO)</label>
      <label>BC (Cd·A/m) — kg⁻¹
        <input id="bc" type="range" min="0.0005" max="0.02" step="0.0005" value="0.005"><span id="bcVal">0.0050</span>
      </label>
      <div><button id="btnXls" class="xls">Esporta telemetria (.xls)</button>
        <p class="small">t,x,y,z,alt_m,a_m,e,i,Ω,ω,M₀,eclissi</p></div>
    </div>

    <!-- Sistema Solare -->
    <div class="group ss-only hidden">
      <label>Scala orbite (AU → pixel)
        <input id="ssScale" type="range" min="80" max="400" step="10" value="260">
        <span id="ssScaleVal">260 px/AU</span>
      </label>
      <label>Scala raggi pianeti (visuale)
        <input id="ssPR" type="range" min="0.5" max="6" step="0.1" value="3.8">
        <span id="ssPRVal">3.8×</span>
      </label>
      <div class="toggles">
        <label><input type="checkbox" id="ssIncl" checked> Orbite inclinate</label>
        <label><input type="checkbox" id="ssTrails" checked> Tracce orbite</label>
        <label><input type="checkbox" id="ssSpin" checked> Rotazione pianeti</label>
        <label><input type="checkbox" id="ssRings" checked> Anelli Saturno</label>
        <label><input type="checkbox" id="ssLabels" checked> Etichette pianeti</label>
      </div>
    </div>
  </section>
  <p class="small">Nessuna dipendenza. Nota: l’autoplay audio può richiedere un click iniziale sul canvas (policy browser).</p>
</main>
<footer>© 2025 — pezzaliAPP</footer>

<script>
(function(){
'use strict';
/* ===== Costanti fisiche & util ===== */
const R_EARTH=6371e3, MU=3.986004418e14, OBLIQUITY=23.44*Math.PI/180, AU=149597870700;
const RHO0=1.225, Hs=8500;

/* ===== Canvas & Camera ===== */
const canvas=document.getElementById('view'), ctx=canvas.getContext('2d');
const hud=document.getElementById('hud');
let W=canvas.width,H=canvas.height,cx=W/2,cy=H/2;
const cam={r:2.8*R_EARTH,theta:-0.8,phi:0.9,fov:900,target:{x:0,y:0,z:0}};

// zoom + orbit drag
let isDragging=false,lastX=0,lastY=0;
canvas.addEventListener('wheel',e=>{e.preventDefault();const k=Math.exp(-e.deltaY*0.0015);cam.r=Math.max(0.05*AU,Math.min(200*AU,cam.r*k));},{passive:false});
canvas.addEventListener('pointerdown',e=>{isDragging=true;lastX=e.clientX;lastY=e.clientY;canvas.setPointerCapture(e.pointerId);});
canvas.addEventListener('pointerup',e=>{isDragging=false;canvas.releasePointerCapture?.(e.pointerId);});
canvas.addEventListener('pointermove',e=>{if(!isDragging)return;const dx=e.clientX-lastX,dy=e.clientY-lastY;lastX=e.clientX;lastY=e.clientY;cam.theta+=dx*0.003;cam.phi=Math.max(-1.25,Math.min(1.25,cam.phi-dy*0.003));});
function onResize(){const r=canvas.getBoundingClientRect(),dpr=window.devicePixelRatio||1;canvas.width=Math.max(800,Math.floor(r.width*dpr));canvas.height=Math.floor(canvas.width*9/16);W=canvas.width;H=canvas.height;cx=W/2;cy=H/2;}
window.addEventListener('resize',onResize);onResize();

/* ===== Math utils ===== */
const toRad=d=>d*Math.PI/180; const V=(x,y,z)=>({x,y,z});
const add=(a,b)=>V(a.x+b.x,a.y+b.y,a.z+b.z), sub=(a,b)=>V(a.x-b.x,a.y-b.y,a.z-b.z);
const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z, mul=(a,s)=>V(a.x*s,a.y*s,a.z*s);
const nrm=a=>{const n=Math.hypot(a.x,a.y,a.z);return n?mul(a,1/n):V(0,0,0);}, crs=(a,b)=>V(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);
function sph(r,th,ph){return V(r*Math.cos(ph)*Math.cos(th),r*Math.sin(ph),r*Math.cos(ph)*Math.sin(th));}
function worldToScreen(p){const camPos=sph(cam.r,cam.theta,cam.phi);const fwd=nrm(sub(cam.target,camPos));const right=nrm(crs(fwd,V(0,1,0)));const up=nrm(crs(right,fwd));const rel=sub(p,camPos);const x=rel.x*right.x+rel.y*right.y+rel.z*right.z;const y=rel.x*up.x+rel.y*up.y+rel.z*up.z;const z=rel.x*fwd.x+rel.y*fwd.y+rel.z*fwd.z;const s=cam.fov/Math.max(1e-6,(cam.fov+z));return {x:cx+x*s,y:cy-y*s,z};}
function projectRadius(r){const a=worldToScreen(V(r,0,0)),b=worldToScreen(V(0,0,0));return Math.hypot(a.x-b.x,a.y-b.y);}

/* ===== Stelle parallax ===== */
const stars=(()=>{const rng=i=>{let x=i*1664525+1013904223;x^=x<<13;x^=x>>17;x^=x<<5;return Math.abs(x)};const layers=[],counts=[140,90,50];for(let L=0;L<3;L++){const arr=[];for(let i=0;i<counts[L];i++){arr.push({x:(rng(i+L*997)%10000)/10000,y:(rng(i+L*233)%10000)/10000});}layers.push(arr);}return layers})();
function drawStars(now){const par=[0.2,0.5,1.0];ctx.save();for(let L=0;L<3;L++){ctx.globalAlpha=0.55+0.15*L;const k=par[L];for(const s of stars[L]){const x=((s.x*W+k*cam.theta*90)%W+W)%W;const y=((s.y*H+k*cam.phi*60)%H+H)%H;const tw=(Math.sin(now*0.001+(s.x+s.y)*50)*0.5+0.5)*0.6+0.2+0.1*L;ctx.fillStyle=`rgba(255,255,255,${tw.toFixed(3)})`;ctx.fillRect(x,y,1,1);}}ctx.restore();}

/* ===== UI base ===== */
const el=id=>document.getElementById(id);
let t=0,timescale=+el('timescale').value;el('timescaleVal').textContent=timescale.toFixed(1)+'×';
el('timescale').oninput=()=>{timescale=+el('timescale').value;el('timescaleVal').textContent=timescale.toFixed(1)+'×';};
const modeSel=el('mode');let mode=modeSel.value;
function togglePanels(){for(const n of document.querySelectorAll('.cs-only'))n.classList.toggle('hidden',mode!=='cubesat');for(const n of document.querySelectorAll('.ss-only'))n.classList.toggle('hidden',mode!=='solarsys');}
modeSel.onchange=()=>{mode=modeSel.value;togglePanels();resetForMode(true);};

/* ===== CubeSat ===== */
const S={scenario:el('scenario'),per:el('perigee'),apo:el('apogee'),incl:el('incl'),raan:el('raan'),argp:el('argp'),m0:el('m0'),trail:el('trail'),
showAxes:el('showAxes'),showOrbit:el('showOrbit'),atmo:el('atmo'),shadow:el('shadow'),drag:el('drag'),bc:el('bc'),
perV:el('perigeeVal'),apoV:el('apogeeVal'),inclV:el('inclVal'),raanV:el('raanVal'),argpV:el('argpVal'),m0V:el('m0Val'),trailV:el('trailVal'),bcV:el('bcVal')};
let perigeeAlt=400e3,apogeeAlt=400e3,inclDeg=51,raanDeg=0,argpDeg=0,m0Deg=0,showAxes=true,showOrbit=true,showAtmo=true,showShadow=true,useDrag=false,BC=0.005,trailMax=800,trail=[];
let a=0,e=0,i=0,RAAN=0,ARGP=0,M0=0,dhAccum=0,lastAlt=null,periodEst=null,orbitTimeAccum=0,dhPerOrbit=0,log=[],logEvery=3,logAcc=0;
function setFromUI(){
  perigeeAlt=+S.per.value*1000;S.perV.textContent=(perigeeAlt/1000).toFixed(0);
  apogeeAlt=+S.apo.value*1000;S.apoV.textContent=(apogeeAlt/1000).toFixed(0);
  inclDeg=+S.incl.value;S.inclV.textContent=inclDeg.toFixed(0);
  raanDeg=+S.raan.value;S.raanV.textContent=raanDeg.toFixed(0);
  argpDeg=+S.argp.value;S.argpV.textContent=argpDeg.toFixed(0);
  m0Deg=+S.m0.value;S.m0V.textContent=m0Deg.toFixed(0);
  trailMax=+S.trail.value;S.trailV.textContent=trailMax.toFixed(0);
  useDrag=S.drag.checked;BC=+S.bc.value;S.bcV.textContent=BC.toFixed(4);
  showAxes=S.showAxes.checked;showOrbit=S.showOrbit.checked;showAtmo=S.atmo.checked;showShadow=S.shadow.checked;
  const rp=R_EARTH+perigeeAlt,ra=R_EARTH+apogeeAlt; a=0.5*(rp+ra); e=(ra-rp)/(ra+rp); i=toRad(inclDeg); RAAN=toRad(raanDeg); ARGP=toRad(argpDeg); M0=toRad(m0Deg);
  trail.length=0;t=0;dhAccum=0;lastAlt=null;orbitTimeAccum=0;log.length=0;logAcc=0;periodEst=2*Math.PI/Math.sqrt(MU/Math.pow(a,3));
  cam.r=2.8*R_EARTH;cam.target=V(0,0,0);
}
S.per.oninput=S.apo.oninput=S.incl.oninput=S.raan.oninput=S.argp.oninput=S.m0.oninput=S.trail.oninput=S.bc.oninput=setFromUI;
S.drag.onchange=setFromUI;S.showAxes.onchange=setFromUI;S.showOrbit.onchange=setFromUI;S.atmo.onchange=setFromUI;S.shadow.onchange=setFromUI;
S.scenario.onchange=()=>{const v=S.scenario.value;
  if(v==='launch'){S.per.value=200;S.apo.value=400;S.incl.value=51;S.raan.value=0;S.argp.value=0;S.m0.value=0;el('timescale').value=3;el('timescale').oninput();S.trail.value=400;}
  else if(v==='leo'){S.per.value=400;S.apo.value=400;S.incl.value=51;S.raan.value=0;S.argp.value=0;S.m0.value=0;el('timescale').value=6;el('timescale').oninput();S.trail.value=800;}
  else if(v==='ellipse'){S.per.value=300;S.apo.value=800;S.incl.value=63;S.raan.value=90;S.argp.value=30;S.m0.value=0;el('timescale').value=8;el('timescale').oninput();S.trail.value=1200;}
  else if(v==='gto'){S.per.value=250;S.apo.value=35786;S.incl.value=27;S.raan.value=20;S.argp.value=180;S.m0.value=0;el('timescale').value=30;el('timescale').oninput();S.trail.value=2000;}
  setFromUI();
};

/* Keplero → stato */
function elementsToState(a,e,i,raan,argp,M0,time){const n=Math.sqrt(MU/Math.pow(a,3));const M=(M0+n*time)%(2*Math.PI);let E=M;for(let k=0;k<8;k++){const f=E-e*Math.sin(E)-M,fp=1-e*Math.cos(E);E-=f/fp;}
const cosE=Math.cos(E),sinE=Math.sin(E);const nu=Math.atan2(Math.sqrt(1-e*e)*sinE,cosE-e);const r=a*(1-e*cosE);const xpf=r*Math.cos(nu),ypf=r*Math.sin(nu);
const cO=Math.cos(raan),sO=Math.sin(raan),ci=Math.cos(i),si=Math.sin(i),co=Math.cos(argp),so=Math.sin(argp);
const x=(cO*co - sO*so*ci)*xpf + (-cO*so - sO*co*ci)*ypf, y=(so*si)*xpf + (co*si)*ypf, z=(sO*co + cO*so*ci)*xpf + (-sO*so + cO*co*ci)*ypf;return {pos:V(x,y,z),r,n};}
function sunDirection(timeSec){const season=timeSec/(200*Math.PI),alpha=season,delta=OBLIQUITY*Math.sin(season);const c=Math.cos(delta),s=Math.sin(delta);return nrm(V(c*Math.cos(alpha),s,c*Math.sin(alpha)));}
function inUmbra(p,sDir){const d=dot(p,sDir);if(d>0)return false;const perp=Math.sqrt(dot(p,p)-d*d);return perp<R_EARTH;}
function applyDrag(dt,st){const rmag=Math.sqrt(dot(st.pos,st.pos)),alt=rmag-R_EARTH;if(alt<120e3)return;const v=Math.sqrt(MU*(2/rmag-1/a)),rho=RHO0*Math.exp(-alt/Hs),k=BC*1e-5;a=Math.max(R_EARTH+100e3,a-k*rho*v*v*v*dt);e=Math.max(0,e-k*0.2*rho*v*v*dt);periodEst=2*Math.PI/Math.sqrt(MU/Math.pow(a,3));}

/* ===== Sistema Solare ===== */
const PLANETS=[{name:'Mercurio',a:0.387,e:0.206,i:7.00,O:48.331,w:29.124,M0:174.796,P:87.969,rE:0.383,color:'#c9b090'},
{name:'Venere',a:0.723,e:0.007,i:3.39,O:76.680,w:54.884,M0:50.115,P:224.701,rE:0.949,color:'#f5d7a1'},
{name:'Terra',a:1.000,e:0.017,i:0.00,O:-11.260,w:114.207,M0:100.464,P:365.256,rE:1.000,color:'#5bb8ff'},
{name:'Marte',a:1.524,e:0.093,i:1.85,O:49.558,w:286.502,M0:19.373,P:686.980,rE:0.532,color:'#ff8c5b'},
{name:'Giove',a:5.203,e:0.049,i:1.31,O:100.464,w:273.867,M0:20.020,P:4332.589,rE:11.21,color:'#f0e1c0'},
{name:'Saturno',a:9.537,e:0.056,i:2.49,O:113.665,w:339.392,M0:317.020,P:10759.22,rE:9.45,color:'#f7e6b1'},
{name:'Urano',a:19.19,e:0.047,i:0.77,O:74.006,w:96.998,M0:142.238,P:30685.4,rE:4.01,color:'#9bdaf5'},
{name:'Nettuno',a:30.07,e:0.009,i:1.77,O:131.784,w:272.846,M0:256.228,P:60189.0,rE:3.88,color:'#6db5ff'}];
let ssScale=+el('ssScale').value, ssPlanetScale=+el('ssPR').value;
const optSS={incl:el('ssIncl'),trails:el('ssTrails'),spin:el('ssSpin'),rings:el('ssRings'),labels:el('ssLabels')};
el('ssScale').oninput=()=>{ssScale=+el('ssScale').value;el('ssScaleVal').textContent=ssScale+' px/AU';if(mode==='solarsys')cam.r=40*AU/ssScale;};
el('ssPR').oninput=()=>{ssPlanetScale=+el('ssPR').value;el('ssPRVal').textContent=ssPlanetScale.toFixed(1)+'×';};
let ssTrails=PLANETS.map(()=>[]);
function kepler2posAU(p,tdays){const n=2*Math.PI/p.P;const M=(toRad(p.M0)+n*tdays)%(2*Math.PI);let E=M;for(let k=0;k<8;k++){const f=E-p.e*Math.sin(E)-M,fp=1-p.e*Math.cos(E);E-=f/fp;}
const nu=Math.atan2(Math.sqrt(1-p.e*p.e)*Math.sin(E),Math.cos(E)-p.e);const r=p.a*(1-p.e*Math.cos(E)),xpf=r*Math.cos(nu),ypf=r*Math.sin(nu);
const O=toRad(p.O),I=toRad(p.i),w=toRad(p.w);const cO=Math.cos(O),sO=Math.sin(O),cI=Math.cos(I),sI=Math.sin(I),cw=Math.cos(w),sw=Math.sin(w);
const x=(cO*cw-sO*sw*cI)*xpf+(-cO*sw-sO*cw*cI)*ypf;const y=(sw*sI)*xpf+(cw*sI)*ypf;const z=(sO*cw+cO*sw*cI)*xpf+(-sO*sw+cO*cw*cI)*ypf;return V(x,y,z);}
function colorTrail(hex){if(!hex.startsWith('#'))return'rgba(173,216,230,0.55)';const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);return `rgba(${r},${g},${b},0.55)`;}
function drawSolarSystem(){
  const c0=worldToScreen(V(0,0,0));const sunRpx=20;const g=ctx.createRadialGradient(c0.x,c0.y,sunRpx*0.2,c0.x,c0.y,sunRpx*1.8);
  g.addColorStop(0,"#fff8c6");g.addColorStop(1,"rgba(255,240,150,0.05)");ctx.fillStyle=g;ctx.beginPath();ctx.arc(c0.x,c0.y,sunRpx*1.8,0,Math.PI*2);ctx.fill();
  ctx.fillStyle="#ffe39a";ctx.beginPath();ctx.arc(c0.x,c0.y,sunRpx,0,Math.PI*2);ctx.fill();
  const showTrails=optSS.trails.checked,spin=optSS.spin.checked,showLabels=optSS.labels.checked;
  PLANETS.forEach((p,idx)=>{
    const tdays=t/86400*timescale;let posAU=kepler2posAU(p,tdays);if(!optSS.incl.checked)posAU=V(posAU.x,posAU.y,0);const pos=V(posAU.x*AU,posAU.y*AU,posAU.z*AU);
    if(showTrails){const arr=ssTrails[idx];arr.push(pos);if(arr.length>1600)arr.shift();ctx.strokeStyle=colorTrail(p.color);ctx.lineWidth=1.2;ctx.beginPath();let s=worldToScreen(arr[0]);ctx.moveTo(s.x,s.y);for(let k=1;k<arr.length;k++){s=worldToScreen(arr[k]);ctx.lineTo(s.x,s.y);}ctx.stroke();}
    const s=worldToScreen(pos);const rpx=Math.max(2,Math.log(1+p.rE)*ssPlanetScale);ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(s.x,s.y,rpx,0,Math.PI*2);ctx.fill();
    if(spin){ctx.strokeStyle="rgba(0,0,0,0.35)";ctx.lineWidth=1;const ang=(tdays/p.P)*Math.PI*2*10;ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(s.x+Math.cos(ang)*rpx,s.y+Math.sin(ang)*rpx);ctx.stroke();}
    if(optSS.rings.checked && p.name==='Saturno'){const tilt=26.7*Math.PI/180,inner=rpx*1.7,outer=rpx*2.8;ctx.save();ctx.translate(s.x,s.y);ctx.rotate(tilt);
      ctx.strokeStyle='rgba(255,255,255,0.35)';ctx.lineWidth=1;ctx.beginPath();ctx.ellipse(0,0,outer,outer*0.35,0,0,Math.PI*2);ctx.stroke();ctx.beginPath();ctx.ellipse(0,0,inner,inner*0.35,0,0,Math.PI*2);ctx.stroke();
      const grd=ctx.createLinearGradient(-outer,0,outer,0);grd.addColorStop(0,'rgba(255,255,255,0.04)');grd.addColorStop(0.5,'rgba(255,255,255,0.10)');grd.addColorStop(1,'rgba(255,255,255,0.04)');
      ctx.fillStyle=grd;ctx.beginPath();ctx.ellipse(0,0,outer,outer*0.35,0,0,Math.PI*2);ctx.ellipse(0,0,inner,inner*0.35,0,0,Math.PI*2);ctx.fill('evenodd');ctx.restore();}
    if(showLabels){ctx.fillStyle="rgba(234,241,255,0.9)";ctx.font="11px ui-monospace, Menlo, monospace";ctx.fillText(p.name,s.x+rpx+4,s.y-rpx-2);}
  });
}

/* ===== Beacon radio: visivo + testo + audio ===== */
// Stato trasmissione
let txTimer=0, txCooldown=60; // ogni 60s simulati
let txPulseR=0, txPulseAlpha=0, txActive=false;
let binAlpha=0, humanAlpha=0, binTimer=0;
let lastSatPosScreen={x:0,y:0};

// Messaggi
const BIN_MSG = "01000011 11001000 00100000 01100011 111000 11001000 01110101 110111 00100000 01101001 01101110 00100000 01100001 01110011 01100011 01101111 01101100 01110100 01101111 00111111";
const HUMAN_MSG = "«C’è qualcuno in ascolto?»";

// Audio (WebAudio)
let audioCtx=null, audioUnlocked=false, audioWarnShown=false;
function ensureAudio(){
  if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} }
  if(audioCtx && audioCtx.state==="suspended"){ audioCtx.resume().then(()=>{audioUnlocked=true;}).catch(()=>{}); }
  if(audioCtx && audioCtx.state==="running"){ audioUnlocked=true; }
  if(!audioUnlocked && !audioWarnShown){ hud.innerHTML += `<br><span class="warn">Audio in attesa: fai un click/tap per sbloccarlo.</span>`; audioWarnShown=true; }
}
function userUnlock(){ ensureAudio(); if(audioUnlocked){ // ripulisci avviso
  hud.innerHTML = hud.textContent.split('\n')[0];
}}
['pointerdown','keydown','touchstart'].forEach(ev=>document.addEventListener(ev,userUnlock,{once:false,passive:true}));
document.addEventListener('visibilitychange',ensureAudio);
setTimeout(ensureAudio,100); // tentativo iniziale

function ping(){
  ensureAudio();
  if(!audioUnlocked || !audioCtx) return;
  const now=audioCtx.currentTime;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type='sine'; o.frequency.setValueAtTime(840,now);
  g.gain.setValueAtTime(0.001,now);
  g.gain.exponentialRampToValueAtTime(0.15, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.0005, now+0.28);
  o.connect(g).connect(audioCtx.destination);
  o.start(now); o.stop(now+0.3);
}

// Disegno e gestione trasmissione (partenza dal CUBESAT)
function startTransmission(){
  txActive=true; txPulseR=1; txPulseAlpha=1; binAlpha=1; humanAlpha=0; binTimer=0;
  ping();
}
function drawTransmission(dt){
  if(!txActive) return;
  // Onda dal Cubesat
  txPulseR += dt*160; // velocità espansione
  txPulseAlpha = Math.max(0, 1 - txPulseR/1400);
  ctx.save();
  ctx.beginPath();
  ctx.arc(lastSatPosScreen.x, lastSatPosScreen.y, txPulseR, 0, Math.PI*2);
  ctx.strokeStyle = `rgba(120,200,255,${txPulseAlpha.toFixed(2)})`;
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();

  // Testi: binario → umano (B)
  if(binAlpha>0){
    binTimer += dt;
    binAlpha = Math.max(0, binAlpha - dt*0.6);
    ctx.save();
    ctx.globalAlpha = binAlpha;
    ctx.font="14px ui-monospace, Menlo, monospace";
    ctx.fillStyle="#9fe3ff";
    ctx.textAlign="center";
    ctx.fillText("[437.5 MHz – AFSK Beacon] IU2PEZ > ALL:", W/2, 54);
    ctx.fillText(BIN_MSG, W/2, 74);
    ctx.restore();
    if(binTimer > 1.0 && humanAlpha===0){ humanAlpha = 1.0; } // dopo 1s inizia il testo umano
  }
  if(humanAlpha>0){
    humanAlpha = Math.max(0, humanAlpha - dt*0.2);
    ctx.save();
    ctx.globalAlpha = humanAlpha;
    ctx.font = "16px ui-monospace, Menlo, monospace";
    ctx.fillStyle = "#a8eaff";
    ctx.textAlign = "center";
    ctx.fillText("Transmitting message…", W/2, 96);
    ctx.font = "20px ui-monospace, Menlo, monospace";
    ctx.fillText(HUMAN_MSG, W/2, 120);
    ctx.restore();
  }
  if(txPulseAlpha<=0.02 && binAlpha<=0 && humanAlpha<=0){ txActive=false; }
}

/* ===== Disegno Terra, orbita, cubesat ===== */
function drawEarth(sDir){
  const R=projectRadius(R_EARTH),c0=worldToScreen(V(0,0,0));
  // penombra/ombra
  const s2=worldToScreen(add(V(0,0,0),mul(sDir,R_EARTH)));
  const vx=c0.x-(s2.x-c0.x),vy=c0.y-(s2.y-c0.y);const gx=c0.x+(vx-c0.x)*0.35,gy=c0.y+(vy-c0.y)*0.35;
  const pen=ctx.createRadialGradient(gx,gy,R*0.9,c0.x,c0.y,R*1.15);pen.addColorStop(0,"rgba(0,0,0,0)");pen.addColorStop(1,"rgba(0,0,0,0.18)");
  ctx.fillStyle=pen;ctx.beginPath();ctx.arc(c0.x,c0.y,R*1.15,0,Math.PI*2);ctx.fill();
  const night=ctx.createRadialGradient(gx,gy,R*0.2,c0.x,c0.y,R*1.05);night.addColorStop(0,"rgba(0,0,0,0)");night.addColorStop(1,"rgba(0,0,0,0.48)");
  ctx.fillStyle=night;ctx.beginPath();ctx.arc(c0.x,c0.y,R,0,Math.PI*2);ctx.fill();
  // mare + atmosfera
  const sea=ctx.createRadialGradient(c0.x-0.3*R,c0.y-0.35*R,R*0.2,c0.x,c0.y,R*1.1);sea.addColorStop(0,"#2a6fdb");sea.addColorStop(1,"#0a1d47");
  ctx.fillStyle=sea;ctx.beginPath();ctx.arc(c0.x,c0.y,R,0,Math.PI*2);ctx.fill();
  const Ra=R*1.04,a=ctx.createRadialGradient(c0.x,c0.y,R*0.95,c0.x,c0.y,Ra);a.addColorStop(0,"rgba(120,200,255,.05)");a.addColorStop(1,"rgba(120,200,255,0)");
  ctx.fillStyle=a;ctx.beginPath();ctx.arc(c0.x,c0.y,Ra,0,Math.PI*2);ctx.fill();

  // assi
  if(el('showAxes').checked){ctx.strokeStyle="rgba(255,255,255,.2)";ctx.lineWidth=1;ctx.beginPath();
    const A=[V(R_EARTH*1.3,0,0),V(-R_EARTH*1.3,0,0),V(0,R_EARTH*1.3,0),V(0,-R_EARTH*1.3,0),V(0,0,R_EARTH*1.3),V(0,0,-R_EARTH*1.3)];
    for(let i=0;i<A.length;i+=2){const a=worldToScreen(A[i]),b=worldToScreen(A[i+1]);ctx.moveTo(a.x,a.y);ctx.lineTo(b.x,b.y);}ctx.stroke();
  }
}
function drawOrbitPath(points){
  if(!el('showOrbit').checked||points.length<2) return;
  ctx.strokeStyle="rgba(96,165,250,.85)"; ctx.lineWidth=1.6; ctx.beginPath();
  let s=worldToScreen(points[0]); ctx.moveTo(s.x,s.y);
  for(let i=1;i<points.length;i++){ s=worldToScreen(points[i]); ctx.lineTo(s.x,s.y); }
  ctx.stroke();
}
function drawCubeSat(p, eclipsed){
  const s = worldToScreen(p), size = Math.max(2,Math.min(14,8+1200/(1+s.z+1e-6)));
  ctx.fillStyle = eclipsed? "rgba(234,241,255,0.6)" : "#eaf1ff";
  ctx.strokeStyle="rgba(0,0,0,.25)"; ctx.beginPath(); ctx.rect(s.x-size/2, s.y-size/2, size, size); ctx.fill(); ctx.stroke();
  ctx.fillStyle = eclipsed? "rgba(96,165,250,0.5)" : "#60a5fa";
  ctx.fillRect(s.x - size*1.9, s.y - size*0.3, size*0.7, size*0.6);
  ctx.fillRect(s.x + size*1.2, s.y - size*0.3, size*0.7, size*0.6);
  // memorizza posizione schermo per il beacon
  lastSatPosScreen = {x:s.x, y:s.y};
}

/* ===== Export Excel ===== */
document.getElementById('btnXls').onclick=function(){let html='<table><thead><tr>';const headers=["t","x","y","z","alt_m","a_m","e","i_deg","RAAN_deg","argp_deg","M0_deg","eclissi"];for(const h of headers)html+=`<th>${h}</th>`;html+='</tr></thead><tbody>';for(const r of log){html+='<tr>' + `<td>${r.t.toFixed(2)}</td><td>${r.x.toFixed(3)}</td><td>${r.y.toFixed(3)}</td><td>${r.z.toFixed(3)}</td>` + `<td>${r.alt_m.toFixed(3)}</td><td>${r.a_m.toFixed(3)}</td><td>${r.e.toFixed(6)}</td>` + `<td>${(+r.i_deg).toFixed(3)}</td><td>${(+r.raan_deg).toFixed(3)}</td><td>${(+r.argp_deg).toFixed(3)}</td>` + `<td>${(+r.m0_deg).toFixed(3)}</td><td>${r.eclipse}</td></tr>`;}html+='</tbody></table>';const blob=new Blob([html],{type:'application/vnd.ms-excel'}),url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download='cubesat_telemetria.xls';a.click();setTimeout(()=>URL.revokeObjectURL(url),1000);};

/* ===== Loop & reset ===== */
const modeInit='solarsys'; // puoi mettere 'cubesat' se preferisci
function resetForMode(forceSSInit=false){
  if(mode==='cubesat'){ el('scenario').value='leo'; el('scenario').dispatchEvent(new Event('change')); }
  else{
    if(forceSSInit){ el('ssScale').value=260; el('ssScaleVal').textContent='260 px/AU'; ssScale=260; }
    cam.r = 40*AU/ssScale; cam.theta = -0.6; cam.phi = 0.5; cam.target=V(0,0,0);
  }
}
el('scenario').dispatchEvent(new Event('change')); togglePanels(); setFromUI();

let last=performance.now();
function loop(now){
  requestAnimationFrame(loop);
  let dt=(now-last)/1000; last=now; if(dt>0.05)dt=0.05;
  cam.theta += 0.02*dt;
  ctx.clearRect(0,0,W,H); drawStars(now);

  if(mode==='cubesat'){
    t += dt*timescale;
    let st;
    if(S.scenario.value==='launch'){const k=Math.max(0,Math.min(1,t/120));st=elementsToState(a,e*k,i*k,RAAN*k,ARGP*k,M0*k,t);}
    else{const st0=elementsToState(a,e,i,RAAN,ARGP,M0,t); if(useDrag)applyDrag(dt*timescale,st0); M0=(M0+Math.sqrt(MU/Math.pow(a,3))*dt*timescale)%(2*Math.PI); st=elementsToState(a,e,i,RAAN,ARGP,M0,t);}
    trail.push(st.pos); if(trail.length>trailMax)trail.shift();

    const sDir = nrm(V(1,0,0)); // direzione Sole semplificata per ombra gradevole
    drawEarth(sDir); drawOrbitPath(trail);
    const eclipsed = inUmbra(st.pos, sDir);
    drawCubeSat(st.pos, eclipsed);

    // Telemetria
    const alt = Math.sqrt(dot(st.pos,st.pos)) - R_EARTH;
    if(lastAlt===null) lastAlt=alt; const dAlt=alt-lastAlt; lastAlt=alt;
    if(useDrag){dhAccum+=dAlt;orbitTimeAccum+=dt*timescale;if(periodEst&&orbitTimeAccum>=periodEst){dhPerOrbit=(dhAccum/1000);dhAccum=0;orbitTimeAccum=0;}} else {dhPerOrbit=0;dhAccum=0;orbitTimeAccum=0;}
    logAcc+=dt*timescale;if(logAcc>=logEvery){logAcc=0;log.push({t,x:st.pos.x,y:st.pos.y,z:st.pos.z,alt_m:alt,a_m:a,e,i_deg:inclDeg,raan_deg:raanDeg,argp_deg:argpDeg,m0_deg:m0Deg,eclipse:eclipsed?1:0}); if(log.length>10000)log.shift();}

    // === Trasmissione ogni 60s simulati (dal CUBESAT) ===
    txTimer += dt*timescale;
    if(txTimer>=txCooldown && !txActive){ txTimer=0; startTransmission(); }
    drawTransmission(dt);

    hud.textContent=`CubeSat | t=${t.toFixed(0)}s | alt=${(alt/1000).toFixed(0)}km | a=${(a/1000).toFixed(0)}km | e=${e.toFixed(3)} | i=${inclDeg|0}° | Ω=${raanDeg|0}° | ω=${argpDeg|0}° | M₀=${m0Deg|0}° | drag:${useDrag?'ON':'OFF'} | BC=${BC.toFixed(4)} | Δh=${dhPerOrbit.toFixed(2)} km/orbit` + (audioUnlocked?"":"\nAudio in attesa: fai click/tap per abilitarlo");

  } else {
    t += dt*timescale*864; cam.r=Math.max(0.05*AU,Math.min(200*AU,cam.r)); drawSolarSystem();
    hud.textContent=`Sistema Solare | t=${(t/86400).toFixed(1)} giorni sim | scala=${ssScale} px/AU | rPlan=${(+el('ssPR').value).toFixed(1)}× | incl:${optSS.incl.checked?'ON':'OFF'} | trails:${optSS.trails.checked?'ON':'OFF'} | spin:${optSS.spin.checked?'ON':'OFF'} | rings:${optSS.rings.checked?'ON':'OFF'}` + (audioUnlocked?"":"\nAudio in attesa: fai click/tap per abilitarlo");
  }
}
requestAnimationFrame(loop);

// Avvio predefinito in Sistema Solare (modifica a piacere)
modeSel.value='solarsys'; mode='solarsys'; togglePanels(); resetForMode(true);
})();
</script>
</body>
</html>
